"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimationHeader = void 0;

var _react = require("react");

var _reactNative = require("react-native");

const useAnimationHeader = _ref => {
  let {
    maxHeaderHeight,
    minHeaderHeight,
    onScroll,
    floating = false
  } = _ref;
  const heightAnim = (0, _react.useRef)(new _reactNative.Animated.Value(0)).current;
  const offset = _reactNative.Platform.OS === 'ios' ? maxHeaderHeight : 0;
  const headerTop = (0, _react.useMemo)(() => {
    if (floating) {
      return _reactNative.Animated.diffClamp(_reactNative.Animated.multiply(heightAnim, -1), minHeaderHeight - maxHeaderHeight, 0);
    }

    return heightAnim.interpolate({
      inputRange: [-offset, maxHeaderHeight - minHeaderHeight - offset],
      outputRange: [0, -(maxHeaderHeight - minHeaderHeight)],
      extrapolate: 'clamp'
    });
  }, [floating, offset, maxHeaderHeight, minHeaderHeight, heightAnim]);
  const contentInset = (0, _react.useMemo)(() => ({
    top: maxHeaderHeight
  }), [maxHeaderHeight]);
  const contentOffset = (0, _react.useMemo)(() => ({
    x: 0,
    y: -offset
  }), [offset]);
  const handleScroll = (0, _react.useCallback)(event => {
    _reactNative.Animated.event([{
      nativeEvent: {
        contentOffset: {
          y: heightAnim
        }
      }
    }], {
      useNativeDriver: false,
      listener: event => {
        if (floating) {
          const offsetY = event.nativeEvent.contentOffset.y;

          if (offsetY < -maxHeaderHeight) {
            heightAnim.extractOffset();
          }
        }
      }
    })(event);

    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);
  }, [onScroll, heightAnim, maxHeaderHeight, floating]);
  return {
    headerTop,
    contentInset,
    contentOffset,
    handleScroll
  };
};

exports.useAnimationHeader = useAnimationHeader;
//# sourceMappingURL=useAnimationHeader.js.map